# -*- coding: utf-8 -*-
"""EXP 002 one walker rho 2_3 and 1_2 reference revival.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HfDAT5ogxfz3XRC6eLQHfiVBeWKuzeXV
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap

# ======================
# 1. CONFIGURATION
# ======================
k = 3  # 3-cycle
N_revival = 8  # Revival period for ρ=2/3
rho_values = [0.5, 2/3]  # Hadamard and revival coin
alpha = 0  # Phase parameters
beta = 0
steps_to_simulate = 12  # Go beyond revival to show periodicity

# ======================
# 2. GENERAL OPERATORS
# ======================

# Basis: |c,x⟩ with c∈{0,1}, x∈{0,1,2}, c changes fastest
basis = [(c, x) for x in range(k) for c in range(2)]
basis_labels = [f'|{c},{x}⟩' for c, x in basis]

def build_coin_operator(rho, alpha=0, beta=0):
    """General coin operator from Dukes paper Eq. (3)"""
    C2 = np.array([
        [np.sqrt(rho), np.sqrt(1-rho)*np.exp(1j*alpha)],
        [np.sqrt(1-rho)*np.exp(1j*beta), -np.sqrt(rho)*np.exp(1j*(alpha+beta))]
    ], dtype=complex)

    # C = I_k ⊗ C2
    C = np.zeros((2*k, 2*k), dtype=complex)
    for i, (c1, x1) in enumerate(basis):
        for j, (c2, x2) in enumerate(basis):
            if x1 == x2:  # I_k part
                C[i, j] = C2[c1, c2]
    return C

def build_shift_operator():
    """Shift operator for k-cycle"""
    S = np.zeros((2*k, 2*k), dtype=complex)
    for j, (c, x) in enumerate(basis):
        if c == 0:
            x_new = (x - 1) % k  # counterclockwise
        else:
            x_new = (x + 1) % k  # clockwise
        i = basis.index((c, x_new))
        S[i, j] = 1
    return S

def build_U(rho, alpha=0, beta=0):
    """Full step operator U = S·C"""
    C = build_coin_operator(rho, alpha, beta)
    S = build_shift_operator()
    return S @ C

# ======================
# 3. SIMULATION FOR DIFFERENT ρ VALUES
# ======================
results = {}

for rho in rho_values:
    print(f"\n{'='*60}")
    print(f"SIMULATION FOR ρ = {rho:.4f} {'(Hadamard)' if rho == 0.5 else '(Revival coin)'}")
    print('='*60)

    # Build operators
    U = build_U(rho, alpha, beta)

    # Initial state |0,0⟩
    psi0 = np.zeros(2*k, dtype=complex)
    psi0[0] = 1

    # Evolution
    psi_list = [psi0.copy()]
    for step in range(1, steps_to_simulate + 1):
        psi_list.append(U @ psi_list[-1])

    # Check revival
    revival_step = None
    for step, psi in enumerate(psi_list):
        if step > 0 and np.allclose(psi, psi0, atol=1e-10):
            revival_step = step
            break

    # Probability distribution
    def position_probability(psi):
        prob = np.zeros(k)
        for x in range(k):
            prob[x] = abs(psi[2*x])**2 + abs(psi[2*x+1])**2
        return prob

    prob_matrix = np.array([position_probability(psi) for psi in psi_list])

    # Entanglement entropy
    def entanglement_entropy(psi):
        # Reduced coin density matrix
        rho_coin = np.zeros((2, 2), dtype=complex)
        for c1 in range(2):
            for c2 in range(2):
                rho_coin[c1, c2] = sum(psi[2*x + c1] * psi[2*x + c2].conj()
                                       for x in range(k))

        # Eigenvalues and entropy
        eigvals = np.linalg.eigvalsh(rho_coin)
        eigvals = np.maximum(eigvals, 0)
        S = -sum(v * np.log2(v) for v in eigvals if v > 1e-12)
        return S.real

    entropy_values = [entanglement_entropy(psi) for psi in psi_list]

    # Store results
    results[rho] = {
        'U': U,
        'psi_list': psi_list,
        'prob_matrix': prob_matrix,
        'entropy': entropy_values,
        'revival_step': revival_step,
        'U_N': np.linalg.matrix_power(U, N_revival) if rho == 2/3 else None
    }

    # Print summary
    print(f"Revival period: {revival_step if revival_step else 'None found (up to step {steps_to_simulate})'}")
    if rho == 2/3:
        print(f"U^{N_revival} = I? {np.allclose(results[rho]['U_N'], np.eye(2*k), atol=1e-10)}")

    print("\nStep | P(0)    P(1)    P(2)    | Entropy S")
    print("-" * 45)
    for step in range(min(9, len(psi_list))):
        p = prob_matrix[step]
        S = entropy_values[step]
        print(f"{step:4} | {p[0]:.4f}   {p[1]:.4f}   {p[2]:.4f}   | {S:.6f}")

# ======================
# 4. VISUALIZATION
# ======================
fig = plt.figure(figsize=(18, 12))

# Custom colormap
cmap = LinearSegmentedColormap.from_list('custom', ['#f7fbff', '#08306b'], N=256)

# Plot 1: Probability heatmaps for both ρ values
for idx, rho in enumerate(rho_values):
    ax = plt.subplot(3, 3, idx + 1)
    prob_matrix = results[rho]['prob_matrix']

    sns.heatmap(prob_matrix.T,
                annot=True,
                fmt=".3f",
                cmap=cmap,
                cbar_kws={'label': 'Probability'},
                xticklabels=range(len(prob_matrix)),
                yticklabels=[f'Pos {x}' for x in range(k)],
                ax=ax)

    title = f'ρ = {rho:.3f} '
    title += '(Hadamard)' if rho == 0.5 else '(Revival coin)'
    if results[rho]['revival_step']:
        title += f'\nRevival at step {results[rho]["revival_step"]}'
    ax.set_title(title, fontweight='bold')
    ax.set_xlabel("Step")
    ax.set_ylabel("Position")

# Plot 2: Entanglement entropy comparison
ax = plt.subplot(3, 3, 3)
for rho in rho_values:
    entropy = results[rho]['entropy']
    label = f'ρ = {rho:.3f}'
    if rho == 2/3:
        label += ' (revival)'
    ax.plot(range(len(entropy)), entropy, 'o-', linewidth=2, markersize=6, label=label)

ax.set_title("Entanglement Entropy Evolution", fontweight='bold')
ax.set_xlabel("Step")
ax.set_ylabel("Von Neumann Entropy S")
ax.grid(True, alpha=0.3)
ax.legend()
ax.axvline(x=8, color='red', linestyle='--', alpha=0.5, label='Step 8')

# Plot 3: State amplitudes at key steps (ρ=2/3)
ax = plt.subplot(3, 3, 4)
rho = 2/3
psi_list = results[rho]['psi_list']
key_steps = [0, 1, 2, 3, 4, 8]
colors = plt.cm.viridis(np.linspace(0, 1, len(key_steps)))

for i, step in enumerate(key_steps):
    amps = np.abs(psi_list[step])
    x_pos = np.arange(2*k) + i*0.15
    ax.bar(x_pos, amps, width=0.15, label=f'Step {step}',
           color=colors[i], alpha=0.8, edgecolor='black', linewidth=0.5)

ax.set_title(f"State Amplitudes (ρ = {rho:.3f})", fontweight='bold')
ax.set_xlabel("Basis State")
ax.set_ylabel("|Amplitude|")
ax.set_xticks(np.arange(2*k) + 0.3)
ax.set_xticklabels(basis_labels, rotation=45, ha='right')
ax.legend(loc='upper right', fontsize=8)
ax.grid(True, alpha=0.3, axis='y')

# Plot 4: Check U^8 for ρ=2/3
ax = plt.subplot(3, 3, 5)
rho = 2/3
U_N = results[rho]['U_N']
if U_N is not None:
    im = ax.imshow(np.abs(U_N), cmap='viridis', vmin=0, vmax=1)
    ax.set_title(f"$|U^{{{N_revival}}}|$ for ρ = {rho:.3f}\n(Should be identity)", fontweight='bold')
    ax.set_xlabel("Column")
    ax.set_ylabel("Row")
    plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)

    # Add text annotation for revival
    is_identity = np.allclose(U_N, np.eye(2*k), atol=1e-10)
    ax.text(0.5, -0.15, f"U^{N_revival} = I? {is_identity}",
            transform=ax.transAxes, ha='center', fontsize=10,
            bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgreen" if is_identity else "lightcoral"))

# Plot 5: Eigenvalue analysis
ax = plt.subplot(3, 3, 6)
for rho in rho_values:
    U = results[rho]['U']
    eigvals = np.linalg.eigvals(U)
    angles = np.angle(eigvals)

    # Plot on unit circle
    for val in eigvals:
        ax.plot([0, val.real], [0, val.imag], 'o-', alpha=0.5, linewidth=1)

    # Plot eigenvalues
    scatter = ax.scatter(np.real(eigvals), np.imag(eigvals),
                        s=100, alpha=0.7, label=f'ρ = {rho:.3f}')

ax.set_aspect('equal')
circle = plt.Circle((0,0), 1, fill=False, color='r', alpha=0.3, linewidth=2)
ax.add_artist(circle)
ax.set_xlim(-1.2, 1.2)
ax.set_ylim(-1.2, 1.2)
ax.axhline(y=0, color='k', alpha=0.2)
ax.axvline(x=0, color='k', alpha=0.2)
ax.grid(True, alpha=0.3)
ax.set_title("Eigenvalues on Unit Circle", fontweight='bold')
ax.set_xlabel("Re(λ)")
ax.set_ylabel("Im(λ)")
ax.legend()

# Plot 6: Revival check across steps (ρ=2/3)
ax = plt.subplot(3, 3, 7)
rho = 2/3
psi_list = results[rho]['psi_list']
revival_strength = []

for step, psi in enumerate(psi_list):
    # Fidelity with initial state
    fidelity = abs(np.vdot(psi0, psi))**2
    revival_strength.append(fidelity)

ax.plot(range(len(revival_strength)), revival_strength, 'o-', linewidth=2)
ax.set_title(f"Fidelity with |0,0⟩ (ρ = {rho:.3f})", fontweight='bold')
ax.set_xlabel("Step")
ax.set_ylabel("Fidelity |⟨ψ₀|ψₙ⟩|²")
ax.grid(True, alpha=0.3)
ax.axhline(y=1, color='green', linestyle='--', alpha=0.5, label='Perfect revival')
ax.axvline(x=8, color='red', linestyle='--', alpha=0.5, label='Step 8')
ax.set_ylim(-0.05, 1.05)
ax.legend()

# Plot 7: Phase space visualization (real vs imag parts)
ax = plt.subplot(3, 3, 8, projection='3d')
rho = 2/3
psi_list = results[rho]['psi_list']

# Plot trajectory in state space (first 3 components)
for step in range(min(9, len(psi_list))):
    psi = psi_list[step]
    # Use first 3 amplitudes for 3D plot
    x = psi[0].real
    y = psi[1].real
    z = psi[2].real

    ax.scatter(x, y, z, s=100, alpha=0.7, label=f'Step {step}')
    if step > 0:
        # Connect steps with lines
        prev_psi = psi_list[step-1]
        ax.plot([prev_psi[0].real, x],
                [prev_psi[1].real, y],
                [prev_psi[2].real, z], 'k-', alpha=0.3)

ax.set_title(f"State Space Trajectory (ρ = {rho:.3f})", fontweight='bold')
ax.set_xlabel("Re(ψ₀)")
ax.set_ylabel("Re(ψ₁)")
ax.set_zlabel("Re(ψ₂)")
ax.grid(True, alpha=0.3)

# Plot 8: Parameter sensitivity around ρ=2/3
ax = plt.subplot(3, 3, 9)
rho_test = np.linspace(0.1, 0.9, 50)
revival_errors = []

for rho_val in rho_test:
    U_test = build_U(rho_val, alpha, beta)
    U8_test = np.linalg.matrix_power(U_test, 8)
    error = np.max(np.abs(U8_test - np.eye(2*k)))
    revival_errors.append(error)

ax.plot(rho_test, revival_errors, 'b-', linewidth=2)
ax.axvline(x=0.5, color='orange', linestyle='--', alpha=0.7, label='Hadamard (ρ=0.5)')
ax.axvline(x=2/3, color='green', linestyle='--', alpha=0.7, label='Revival (ρ=2/3)')
ax.set_title("Sensitivity to ρ Parameter", fontweight='bold')
ax.set_xlabel("ρ (coin parameter)")
ax.set_ylabel(f"Max error in U⁸")
ax.grid(True, alpha=0.3)
ax.set_yscale('log')
ax.legend()
ax.text(2/3, min(revival_errors)*1.5, 'Perfect revival',
        ha='center', va='bottom', color='green', fontweight='bold')

plt.suptitle(f"Quantum Walk on {k}-Cycle: Hadamard vs Revival Coin (ρ=2/3)",
             fontsize=16, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# ======================
# 5. ADDITIONAL ANALYSIS
# ======================
print("\n" + "="*60)
print("ADDITIONAL ANALYSIS")
print("="*60)

# Check eigenvalues for ρ=2/3 are 8th roots of unity
rho = 2/3
U = results[rho]['U']
eigvals = np.linalg.eigvals(U)
print(f"\nEigenvalues for ρ = {rho:.3f}:")
print("λ      |λ|     Argument/π   λ^8")
for i, val in enumerate(eigvals):
    arg = np.angle(val) / np.pi
    print(f"{val:.4f}  {abs(val):.6f}  {arg:.6f}       {(val**8):.6f}")

# Show that these are 8th roots of unity
print("\nThese should be 8th roots of unity:")
expected_phases = [0, 1/4, 1/2, 3/4, 1, 5/4, 3/2, 7/4]  # Multiples of π/4
for phase in expected_phases:
    val = np.exp(1j * np.pi * phase)
    print(f"exp(iπ·{phase:.3f}) = {val:.4f}, (value)^8 = {(val**8):.4f}")

# Verify specific states from evolution
print(f"\nVerifying revival at step 8 for ρ = {rho:.3f}:")
psi8 = results[rho]['psi_list'][8]
print(f"ψ₈ = {np.round(psi8, 6)}")
print(f"Matches ψ₀? {np.allclose(psi8, psi0, atol=1e-10)}")
print(f"Fidelity = {abs(np.vdot(psi0, psi8))**2:.10f}")